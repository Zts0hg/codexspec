# CodexSpec

[English](README.md) | [中文](README.zh-CN.md) | **日本語** | [Español](README.es.md) | [Português](README.pt-BR.md) | [한국어](README.ko.md) | [Deutsch](README.de.md) | [Français](README.fr.md)

[![PyPI version](https://img.shields.io/pypi/v/codexspec.svg)](https://pypi.org/project/codexspec/)
[![Python](https://img.shields.io/pypi/pyversions/codexspec.svg)](https://pypi.org/project/codexspec/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**[📖 ドキュメント](https://zts0hg.github.io/codexspec/)**

**Claude Code 向けスペック駆動開発 (SDD) ツールキット**

CodexSpec は、構造化されたスペック駆動アプローチを使用して高品質なソフトウェアを構築するのに役立つツールキットです。仕様を実行可能なアーティファクトに変換し、実装を直接ガイドすることで、従来の開発手法を一新します。

## 設計哲学：人間-AI協調

CodexSpecは**効果的なAIアシスト開発には各段階での積極的な人間の参加が必要**という信念に基づいて構築されています。このツールキットは核心原則を中心に設計されています：

> **各アーティファクトを進める前にレビュー・検証する。**

### 人間の監視が重要な理由

AIアシスト開発では、レビュー段階をスキップすると以下の問題が発生します：

| 問題 | 結果 |
|------|------|
| 不明確な要件 | AIがあなたの意図と乖離した仮定を立てる |
| 不完全なスペック | 重要なエッジケースなしで機能が構築される |
| 不整合な技術計画 | アーキテクチャがビジネスニーズと一致しない |
| 曖昧なタスク分解 | 実装が脱線し、高価なやり直しが必要になる |

### CodexSpecのアプローチ

CodexSpecは開発を**レビュー可能なチェックポイント**に構造化します：

```
アイデア → 明確化 → レビュー → 計画 → レビュー → タスク → レビュー → 分析 → 実装
                 ↑              ↑              ↑
              人間チェック      人間チェック      人間チェック
```

**すべてのアーティファクトに対応するレビューコマンドがあります：**
- `spec.md` → `/codexspec.review-spec`
- `plan.md` → `/codexspec.review-plan`
- `tasks.md` → `/codexspec.review-tasks`
- すべてのアーティファクト → `/codexspec.analyze`

この体系的なレビュープロセスは以下を保証します：
- **早期エラー検出**: コードが書かれる前に誤解をキャッチ
- **整合性検証**: AIの解釈があなたの意図と一致していることを確認
- **品質ゲート**: 各段階で完全性、明確性、実現可能性を検証
- **やり直しの削減**: レビューに数分投資して、再実装の時間を節約

## 特徴

### コアSDDワークフロー
- **憲法ベース**: すべての後続の決定をガイドするプロジェクト原則を確立
- **2段階スペック作成**: インタラクティブな明確化（`/specify`）に続くドキュメント生成（`/generate-spec`）
- **プラン駆動開発**: 技術選択は要件の検証後に行う
- **TDD対応タスク**: タスク分解がテストファースト手法を強制

### 人間-AI協調
- **レビューコマンド**: AI出力を検証するためのスペック、計画、タスク専用のレビューコマンド
- **インタラクティブ明確化**: 即座のフィードバックを伴うQ&Aベースの要件精緻化
- **クロスアーティファクト分析**: 実装前にスペック、計画、タスク間の不整合を検出
- **品質チェックリスト**: 要件の自動品質評価

### 開発者体験
- **Claude Code 統合**: Claude Code のネイティブスラッシュコマンド
- **国際化 (i18n)**: LLM ダイナミック翻訳による多言語サポート
- **クロスプラットフォーム**: Bash と PowerShell スクリプトの両方をサポート
- **拡張可能**: カスタムコマンド用のプラグインアーキテクチャ

## インストール

### 前提条件

- Python 3.11+
- [uv](https://docs.astral.sh/uv/)（推奨）または pip

### 方法 1: uv でインストール（推奨）

uv を使用するのが最も簡単なインストール方法です：

```bash
uv tool install codexspec
```

### 方法 2: pip でインストール

または pip を使用：

```bash
pip install codexspec
```

### 方法 3: 一時使用

インストールせずに直接実行：

```bash
# 新しいプロジェクトを作成
uvx codexspec init my-project

# 既存のプロジェクトで初期化
cd your-existing-project
uvx codexspec init . --ai claude
```

### 方法 4: GitHub からインストール（開発版）

最新の開発版または特定のブランチからインストール：

```bash
# uv を使用
uv tool install git+https://github.com/Zts0hg/codexspec.git

# pip を使用
pip install git+https://github.com/Zts0hg/codexspec.git

# 特定のブランチまたはタグ
uv tool install git+https://github.com/Zts0hg/codexspec.git@main
uv tool install git+https://github.com/Zts0hg/codexspec.git@v0.2.0
```

## クイックスタート

インストール後、CLI を使用できます：

```bash
# 新しいプロジェクトを作成
codexspec init my-project

# 日本語出力でプロジェクトを作成
codexspec init my-project --lang ja

# 既存のプロジェクトで初期化
codexspec init . --ai claude
# または
codexspec init --here --ai claude

# インストールされたツールを確認
codexspec check

# バージョンを表示
codexspec version
```

最新版にアップグレード：

```bash
# uv を使用
uv tool install codexspec --upgrade

# pip を使用
pip install --upgrade codexspec
```

## 使用方法

### 1. プロジェクトの初期化

[インストール](#インストール)後、プロジェクトを作成または初期化します：

```bash
codexspec init my-awesome-project
# または現在のディレクトリで
codexspec init . --ai claude
```

### 2. プロジェクト原則の確立

プロジェクトディレクトリで Claude Code を起動します：

```bash
cd my-awesome-project
claude
```

`/codexspec.constitution` コマンドを使用してプロジェクトのガバナンス原則を作成します：

```
/codexspec.constitution コード品質、テスト標準、クリーンアーキテクチャに焦点を当てた原則を作成
```

### 3. 要件の明確化

`/codexspec.specify` を使用して、インタラクティブなQ&Aで要件を**探索・明確化**します：

```
/codexspec.specify タスク管理アプリケーションを構築したい
```

このコマンドは：
- アイデアを理解するための明確化質問を行う
- 考慮されていないエッジケースを探索
- ダイアログを通じて高品質な要件を共創
- ファイルを自動生成**しない** - ユーザーがコントロール

### 4. スペックドキュメントの生成

要件が明確になったら、`/codexspec.generate-spec` を使用して `spec.md` ドキュメントを作成します：

```
/codexspec.generate-spec
```

このコマンドは「要件コンパイラ」として機能し、明確化された要件を構造化されたスペックドキュメントに変換します。

### 5. スペックのレビュー（推奨）

**計画に進む前に、スペックを検証します：**

```
/codexspec.review-spec
```

このコマンドは以下を含む詳細なレビューレポートを生成します：
- セクション完全性分析
- 明確性とテスト可能性評価
- 憲法整合性チェック
- 優先順位付けされた推奨事項

### 6. 技術計画の作成

`/codexspec.spec-to-plan` を使用して実装方法を定義します：

```
/codexspec.spec-to-plan バックエンドに Python と FastAPI、データベースに PostgreSQL、フロントエンドに React を使用
```

このコマンドには**憲法整合性レビュー**が含まれ、計画がプロジェクト原則と整合しているかを検証します。

### 7. 計画のレビュー（推奨）

**タスクに分解する前に、技術計画を検証します：**

```
/codexspec.review-plan
```

これが検証するもの：
- スペック整合性
- アーキテクチャの健全性
- 技術スタックの適切性
- 憲法準拠

### 8. タスクの生成

`/codexspec.plan-to-tasks` を使用して計画を分解します：

```
/codexspec.plan-to-tasks
```

タスクは以下を含む標準フェーズに整理されます：
- **TDD強制**: テストタスクが実装タスクに先行
- **並列マーカー `[P]`**: 独立したタスクを識別
- **ファイルパス指定**: タスクごとに明確な成果物

### 9. タスクのレビュー（推奨）

**実装前に、タスク分解を検証します：**

```
/codexspec.review-tasks
```

これがチェックするもの：
- 計画カバレッジ
- TDD準拠
- 依存関係の正確性
- タスク粒度

### 10. 分析（オプションだが推奨）

`/codexspec.analyze` を使用してクロスアーティファクト整合性チェックを行います：

```
/codexspec.analyze
```

これがスペック、計画、タスク全体の問題を検出：
- カバレッジギャップ（タスクのない要件）
- 重複と不整合
- 憲法違反
- 不十分に指定された項目

### 11. 実装

`/codexspec.implement-tasks` を使用して実装を実行します：

```
/codexspec.implement-tasks
```

実装は**条件付きTDDワークフロー**に従います：
- コードタスク: テストファースト（Red → Green → Verify → Refactor）
- 非テスト可能タスク（docs, config）: 直接実装

## 利用可能なコマンド

### CLI コマンド

| コマンド | 説明 |
|----------|------|
| `codexspec init` | 新しい CodexSpec プロジェクトを初期化 |
| `codexspec check` | インストールされたツールを確認 |
| `codexspec version` | バージョン情報を表示 |
| `codexspec config` | プロジェクト設定を表示または変更 |

### `codexspec init` オプション

| オプション | 説明 |
|------------|------|
| `PROJECT_NAME` | 新しいプロジェクトディレクトリの名前 |
| `--here`, `-h` | 現在のディレクトリで初期化 |
| `--ai`, `-a` | 使用する AI アシスタント（デフォルト：claude） |
| `--lang`, `-l` | 出力言語（例：en, zh-CN, ja） |
| `--force`, `-f` | 既存のファイルを強制上書き |
| `--no-git` | git 初期化をスキップ |
| `--debug`, `-d` | デバッグ出力を有効化 |

### `codexspec config` オプション

| オプション | 説明 |
|------------|------|
| `--set-lang`, `-l` | 出力言語を設定 |
| `--set-commit-lang`, `-c` | コミットメッセージ言語を設定（デフォルトは出力言語） |
| `--list-langs` | サポートされている言語を一覧表示 |

### スラッシュコマンド

初期化後、Claude Code で以下のスラッシュコマンドが利用可能です：

#### コアワークフローコマンド

| コマンド | 説明 |
|----------|------|
| `/codexspec.constitution` | クロスアーティファクト検証と同期影響レポート付きでプロジェクト憲法を作成または更新 |
| `/codexspec.specify` | インタラクティブなQ&Aで要件を**明確化**（ファイル生成なし） |
| `/codexspec.generate-spec` | 要件明確化後に `spec.md` ドキュメントを**生成** |
| `/codexspec.spec-to-plan` | 憲法整合性レビューとモジュール依存グラフ付きでスペックを技術計画に変換 |
| `/codexspec.plan-to-tasks` | 並列マーカー `[P]` 付きのアトミックでTDD強制タスクに計画を分解 |
| `/codexspec.implement-tasks` | 条件付きTDDワークフローでタスクを実行（コードはTDD、docs/configは直接） |

#### レビューコマンド（品質ゲート）

| コマンド | 説明 |
|----------|------|
| `/codexspec.review-spec` | スコアリング付きで完全性、明確性、一貫性、テスト可能性をスペック検証 |
| `/codexspec.review-plan` | 実現可能性、アーキテクチャ品質、憲法整合性の技術計画レビュー |
| `/codexspec.review-tasks` | 計画カバレッジ、TDD準拠、依存関係、粒度のタスク分解検証 |

#### 拡張コマンド

| コマンド | 説明 |
|----------|------|
| `/codexspec.clarify` | 4つの集中カテゴリを使用して既存のspec.mdを曖昧さスキャン、レビュー結果と統合 |
| `/codexspec.analyze` | 重要度ベースの問題検出付きで非破壊的クロスアーティファクト分析（スペック、計画、タスク） |
| `/codexspec.checklist` | 要件検証用の品質チェックリストを生成 |
| `/codexspec.tasks-to-issues` | プロジェクト管理統合のためにタスクをGitHub issuesに変換 |

#### Git ワークフローコマンド

| コマンド | 説明 |
|----------|------|
| `/codexspec.commit` | gitステータスとセッションコンテキストに基づいてConventional Commitsメッセージを生成 |
| `/codexspec.commit-staged` | ステージ済みの変更のみからコミットメッセージを生成 |

## ワークフロー概要

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    CodexSpec 人間-AI協調ワークフロー                       │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. Constitution  ──►  クロスアーティファクト検証付きで                    │
│         │                 プロジェクト原則を定義                          │
│         ▼                                                                │
│  2. Specify  ───────►  インタラクティブQ&Aで要件を明確化                   │
│         │               （ファイル作成なし - 人間制御）                    │
│         ▼                                                                │
│  3. Generate Spec  ─►  spec.md ドキュメントを作成                         │
│         │                                                                │
│         ▼                                                                │
│  ╔═══════════════════════════════════════════════════════════════════╗   │
│  ║  ★ レビューゲート 1: /codexspec.review-spec ★                       ║   │
│  ║  検証: 完全性、明確性、テスト可能性、憲法                            ║   │
│  ╚═══════════════════════════════════════════════════════════════════╝   │
│         │                                                                │
│         ▼                                                                │
│  4. Clarify  ───────►  曖昧さを解決（反復的）                             │
│         │               4つの集中カテゴリ、最大5問                        │
│         ▼                                                                │
│  5. Spec to Plan  ──►  技術計画を作成:                                    │
│         │               • 憲法整合性レビュー（必須）                      │
│         │               • モジュール依存グラフ                            │
│         ▼                                                                │
│  ╔═══════════════════════════════════════════════════════════════════╗   │
│  ║  ★ レビューゲート 2: /codexspec.review-plan ★                       ║   │
│  ║  検証: スペック整合性、アーキテクチャ、技術スタック、フェーズ        ║   │
│  ╚═══════════════════════════════════════════════════════════════════╝   │
│         │                                                                │
│         ▼                                                                │
│  6. Plan to Tasks  ─►  アトミックタスクを生成:                            │
│         │               • TDD強制（実装前にテスト）                       │
│         │               • 並列マーカー [P]                               │
│         │               • ファイルパス指定                               │
│         ▼                                                                │
│  ╔═══════════════════════════════════════════════════════════════════╗   │
│  ║  ★ レビューゲート 3: /codexspec.review-tasks ★                      ║   │
│  ║  検証: カバレッジ、TDD準拠、依存関係、粒度                          ║   │
│  ╚═══════════════════════════════════════════════════════════════════╝   │
│         │                                                                │
│         ▼                                                                │
│  7. Analyze  ───────►  クロスアーティファクト整合性チェック               │
│         │               ギャップ、重複、憲法問題を検出                    │
│         ▼                                                                │
│  8. Implement  ─────►  条件付きTDDワークフローで実行                      │
│                          コード: テストファースト | Docs/Config: 直接      │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

**重要な洞察**: 各レビューゲート（★）は、より多くの時間を投資する前にAI出力を検証する**人間チェックポイント**です。これらのゲートをスキップすると、高価なやり直しにつながることがよくあります。

### 重要概念：要件明確化ワークフロー

CodexSpecはワークフローの異なる段階に対して**2つの異なる明確化コマンド**を提供します：

#### specify vs clarify：どちらを使うべきか？

| 側面 | `/codexspec.specify` | `/codexspec.clarify` |
|------|----------------------|----------------------|
| **目的** | 初期要件の探索 | 既存スペックの反復的な精緻化 |
| **使用タイミング** | 新しいアイデアから開始、spec.mdなし | spec.mdが存在、ギャップを埋める必要あり |
| **入力** | あなたの初期アイデアまたは要件 | 既存のspec.mdファイル |
| **出力** | なし（ダイアログのみ） | 明確化内容でspec.mdを更新 |
| **方法** | オープンエンドのQ&A | 構造化された曖昧さスキャン（4カテゴリ） |
| **質問制限** | 無制限 | 最大5問 |
| **典型的な用途** | "ToDoアプリを構築したい" | "スペックにエラー処理の詳細がない" |

#### 2段階スペック作成

ドキュメント生成の前に：

| 段階 | コマンド | 目的 | 出力 |
|------|----------|------|------|
| **探索** | `/codexspec.specify` | インタラクティブQ&Aで要件を探索・精緻化 | なし（ダイアログのみ） |
| **生成** | `/codexspec.generate-spec` | 明確化された要件を構造化ドキュメントにコンパイル | `spec.md` |

#### 反復的明確化

spec.md作成後：

```
spec.md ──► /codexspec.clarify ──► 更新されたspec.md（Clarificationsセクション付き）
                │
                └── 4つの集中カテゴリで曖昧さをスキャン：
                    • 完全性ギャップ - 欠落セクション、空のコンテンツ
                    • 特異性の問題 - 曖昧な用語、未定義の制約
                    • 振る舞いの明確さ - エラー処理、状態遷移
                    • 測定可能性の問題 - メトリクスのない非機能要件
```

#### この設計の利点

- **人間-AI協調**：要件発見に積極的に参加
- **明示的制御**：あなたが決定したときのみファイルを作成
- **品質重視**：ドキュメント化の前に要件を十分に探索
- **反復的精緻化**：理解が深まるにつれてスペックを段階的に改善

## プロジェクト構造

初期化後、プロジェクトは以下の構造になります：

```
my-project/
├── .codexspec/
│   ├── memory/
│   │   └── constitution.md    # プロジェクトのガバナンス原則
│   ├── specs/
│   │   └── {feature-id}/
│   │       ├── spec.md        # 機能スペック
│   │       ├── plan.md        # 技術計画
│   │       ├── tasks.md       # タスク分解
│   │       └── checklists/    # 品質チェックリスト
│   ├── templates/             # カスタムテンプレート
│   ├── scripts/               # ヘルパースクリプト
│   │   ├── bash/              # Bash スクリプト
│   │   └── powershell/        # PowerShell スクリプト
│   └── extensions/            # カスタム拡張
├── .claude/
│   └── commands/              # Claude Code 用スラッシュコマンド
└── CLAUDE.md                  # Claude Code 用コンテキスト
```

## 国際化 (i18n)

CodexSpec は **LLM ダイナミック翻訳**を通じて複数の言語をサポートしています。翻訳されたテンプレートを維持するのではなく、Claude が実行時に言語設定に基づいてコンテンツを翻訳します。

### 言語設定

**初期化時：**
```bash
# 日本語出力でプロジェクトを作成
codexspec init my-project --lang ja

# 中国語出力でプロジェクトを作成
codexspec init my-project --lang zh-CN
```

**初期化後：**
```bash
# 現在の設定を表示
codexspec config

# 言語設定を変更
codexspec config --set-lang zh-CN

# サポートされている言語を一覧表示
codexspec config --list-langs
```

### コミットメッセージ言語

出力言語とは別にコミットメッセージの言語を設定できます：

```bash
# インタラクションは日本語、コミットメッセージは英語
codexspec config --set-lang ja
codexspec config --set-commit-lang en
```

**コミットメッセージの言語優先順位：**
1. `language.commit` 設定（指定されている場合）
2. `language.output`（フォールバック）
3. `"en"`（デフォルト）

**注意：** コミットタイプ（feat、fix、docsなど）とスコープは常に英語のままです。説明部分のみが設定された言語を使用します。

### 設定ファイル

`.codexspec/config.yml` ファイルに言語設定が保存されます：

```yaml
version: "1.0"

language:
  # Claude のやり取りと生成ドキュメントの出力言語
  output: "zh-CN"

  # コミットメッセージ言語（デフォルトは出力言語）
  # 出力言語に関わらず英語のコミットメッセージにする場合は "en" に設定
  commit: "zh-CN"

  # テンプレート言語 - 互換性のため "en" を維持
  templates: "en"

project:
  ai: "claude"
  created: "2026-02-15"
```

### サポートされている言語

| コード | 言語 |
|--------|------|
| `en` | English（デフォルト） |
| `zh-CN` | 中文（简体） |
| `zh-TW` | 中文（繁體） |
| `ja` | 日本語 |
| `ko` | 한국어 |
| `es` | Español |
| `fr` | Français |
| `de` | Deutsch |
| `pt` | Português |
| `ru` | Русский |
| `it` | Italiano |
| `ar` | العربية |
| `hi` | हिन्दी |

### 仕組み

1. **単一の英語テンプレート**: すべてのコマンドテンプレートは英語のまま
2. **言語設定**: プロジェクトが出力言語の設定を指定
3. **動的翻訳**: Claude が英語の指示を読み、ターゲット言語で出力
4. **コンテキスト認識**: 技術用語（JWT、OAuth など）は必要に応じて英語のまま

### メリット

- **翻訳メンテナンス不要**: 複数のテンプレートバージョンを維持する必要がない
- **常に最新**: テンプレートの更新は自動的にすべての言語に反映
- **コンテキスト認識翻訳**: Claude が自然で状況に適した翻訳を提供
- **無制限の言語**: Claude がサポートする任意の言語が即座に利用可能

### Constitution と生成ドキュメント

`/codexspec.constitution` を使用してプロジェクトの constitution を作成すると、設定で指定した言語で生成されます：

- **単一ファイルアプローチ**: Constitution は1つの言語でのみ生成されます
- **Claude は全言語を理解**: Claude はサポートされている任意の言語の constitution ファイルを処理できます
- **チームコラボレーション**: チームは一貫した作業言語を使用すべきです

この設計により、複数の言語バージョン間の同期問題を回避し、メンテナンスのオーバーヘッドを削減できます。

## 拡張システム

CodexSpec はカスタムコマンドを追加するためのプラグインアーキテクチャをサポートしています：

### 拡張の構造

```
my-extension/
├── extension.yml          # 拡張マニフェスト
├── commands/              # カスタムスラッシュコマンド
│   └── command.md
└── README.md
```

### 拡張の作成

1. `extensions/template/` からテンプレートをコピー
2. `extension.yml` を拡張の詳細で変更
3. `commands/` にカスタムコマンドを追加
4. ローカルでテストして公開

詳細は `extensions/EXTENSION-DEVELOPMENT-GUIDE.md` を参照してください。

## 開発

### 前提条件

- Python 3.11+
- uv パッケージマネージャー
- Git

### ローカル開発

```bash
# リポジトリをクローン
git clone https://github.com/Zts0hg/codexspec.git
cd codexspec

# 開発依存関係をインストール
uv sync --dev

# ローカルで実行
uv run codexspec --help

# テストを実行
uv run pytest

# コードをリント
uv run ruff check src/
```

### ビルド

```bash
# パッケージをビルド
uv build
```

## spec-kit との比較

CodexSpec は GitHub の spec-kit に触発されていますが、いくつかの重要な違いがあります：

| 機能 | spec-kit | CodexSpec |
|------|----------|-----------|
| コア思想 | スペック駆動開発 | スペック駆動開発 + 人間-AI協調 |
| CLI 名 | `specify` | `codexspec` |
| 主要 AI | マルチエージェントサポート | Claude Code に注力 |
| コマンドプレフィックス | `/speckit.*` | `/codexspec.*` |
| 憲法システム | 基本 | クロスアーティファクト検証付きの完全な憲法 |
| 2段階スペック | なし | あり（明確化 + 生成） |
| レビューコマンド | オプション | スコアリング付きの3つの専用レビューコマンド |
| Clarify コマンド | あり | 4つの集中カテゴリ、レビュー統合 |
| Analyze コマンド | あり | 読み取り専用、重要度ベース、憲法認識 |
| タスクのTDD | オプション | 強制（テストが実装に先行） |
| 実装 | 標準 | 条件付きTDD（コード vs docs/config） |
| 拡張システム | あり | あり |
| PowerShell スクリプト | あり | あり |
| i18n サポート | なし | あり（LLM 翻訳で 13 以上の言語） |

### 主要な差別化要因

1. **レビューファースト文化**: すべての主要なアーティファクトに専用のレビューコマンド
2. **憲法ガバナンス**: 原則は単に文書化されるだけでなく、検証される
3. **デフォルトでTDD**: テストファースト手法がタスク生成に強制される
4. **人間チェックポイント**: ワークフローは検証ゲートを中心に設計されている

## フィロソフィー

CodexSpec は以下の核心原則に従います：

### SDD基本原則

1. **意図駆動開発**: スペックは「どう」の前に「何」を定義する
2. **リッチなスペック作成**: ガードレールと組織原則を使用
3. **マルチステップ洗練**: ワンショットのコード生成ではなく
4. **憲法ガバナンス**: プロジェクト原則がすべての決定をガイド

### 人間-AI協調原則

5. **人間-in-the-loop**: AIがアーティファクトを生成、人間が検証
6. **レビュー指向**: 各アーティファクトを進める前に検証
7. **段階的開示**: 複雑な情報は徐々に明示
8. **暗黙より明示**: 要件は仮定ではなく明確であるべき

### 品質保証原則

9. **デフォルトでテスト駆動**: TDDワークフローがタスク生成に組み込まれている
10. **クロスアーティファクト一貫性**: スペック、計画、タスクを一緒に分析
11. **憲法整合性**: すべてのアーティファクトがプロジェクト原則を尊重

### レビューが重要な理由

| レビューなし | レビューあり |
|--------------|--------------|
| AIが誤った仮定を立てる | 人間が誤解を早期にキャッチ |
| 不完全な要件が伝播 | 実装前にギャップを特定 |
| アーキテクチャが意図から逸脱 | 各段階で整合性を検証 |
| タスクが重要な機能を見逃す | カバレッジを体系的に検証 |
| **結果: やり直し、無駄な努力** | **結果: 一発で正しい** |

## 貢献

貢献を歓迎します！プルリクエストを提出する前に貢献ガイドラインをお読みください。

## ライセンス

MIT ライセンス - 詳細は [LICENSE](LICENSE) を参照。

## 謝辞

- [GitHub spec-kit](https://github.com/github/spec-kit) に触発
- [Claude Code](https://claude.ai/code) のために構築
